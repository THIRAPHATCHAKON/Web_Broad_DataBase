// server/src/index.js  (CommonJS)
const Report = require("./models/Report");
const express = require("express");
const cors = require("cors");
const path = require("path");
const fs = require("fs");
const cookieParser = require("cookie-parser");
const multer = require("multer");                 // üëà ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ
const { PrismaClient } = require("@prisma/client");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
const prisma = new PrismaClient();
const app = express();

const mongoose = require("mongoose");
mongoose.connect(process.env.MONGODB_URI || "mongodb://localhost:27017/miniforum");
/* ---------- middlewares ---------- */
app.use(cors({ origin: "http://localhost:5173", credentials: true })); // ‡πÉ‡∏´‡πâ‡∏ï‡∏±‡∏ß‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏û‡∏≠
app.use(express.json());
app.use(cookieParser());

// ‡πÄ‡∏™‡∏¥‡∏£‡πå‡∏ü‡πÑ‡∏ü‡∏•‡πå‡∏à‡∏≤‡∏Å server/static -> /static/**
app.use("/static", express.static(path.join(__dirname, "../static")));

/* ---------- upload (multer) ---------- */
const uploadDirs = {
  thread: path.join(__dirname, "../static/thread_images"),
  avatar: path.join(__dirname, "../static/avatars")
};
Object.values(uploadDirs).forEach(dir => fs.mkdirSync(dir, { recursive: true }));

const threadStorage = multer.diskStorage({
  destination: (req, file, cb) => cb(null, uploadDirs.thread),
  filename: (req, file, cb) => {
    const ext = path.extname(file.originalname);
    cb(null, `thread-${Date.now()}${ext}`);
  }
});


const avatarStorage = multer.diskStorage({
  destination: (req, file, cb) => cb(null, uploadDirs.avatar),
  filename: (req, file, cb) => {
    const ext = path.extname(file.originalname);
    cb(null, `avatar-${Date.now()}${ext}`);
  }
});

// ‡∏™‡∏£‡πâ‡∏≤‡∏á multer instances
const uploadThread = multer({ storage: threadStorage });
const uploadAvatar = multer({ storage: avatarStorage });
/* ---------- health ---------- */
app.get('/api/health', (req, res) => {
  res.json({ ok: true, time: new Date().toISOString() });
});

/* ---------- auth ---------- */
app.post("/api/register", async (req, res) => {
  try {
    const { username, email, password } = req.body || {};
    if (!username || !email || !password) {
      return res.status(400).json({ ok: false, message: "‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö" });
    }
    if (password.length < 6) {
      return res.status(400).json({ ok: false, message: "‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 6 ‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£" });
    }

    const passHash = await bcrypt.hash(password, 10);
    const user = await prisma.user.create({
      data: {
        username,
        email,
        passHash,
        role: "user",
        // ‡∏ñ‡πâ‡∏≤‡∏ï‡∏±‡πâ‡∏á default ‡πÑ‡∏ß‡πâ‡πÉ‡∏ô schema ‡∏Å‡πá‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏™‡πà‡∏á‡∏ü‡∏¥‡∏•‡∏î‡πå‡∏ô‡∏µ‡πâ
        avatarUrl: "/static/avatars/default.png",
      },
      select: { id: true, username: true, email: true, role: true, avatarUrl: true },
    });

    return res.json({ ok: true, message: "‡∏™‡∏°‡∏±‡∏Ñ‡∏£‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à", user });
  } catch (err) {
    if (err.code === "P2002") {
      const field = err.meta?.target?.[0] || "‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•";
      return res.status(409).json({ ok: false, message: `${field} ‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡πÉ‡∏ä‡πâ‡πÅ‡∏•‡πâ‡∏ß` });
    }
    console.error(err);
    return res.status(500).json({ ok: false, message: "server error" });
  }
});

app.post("/api/login", async (req, res) => {
  const { email, password } = req.body || {};
  const user = await prisma.user.findUnique({ where: { email } });
  if (!user) return res.status(401).json({ ok: false, message: "‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏´‡∏£‡∏∑‡∏≠‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á" });

  const ok = await bcrypt.compare(password, user.passHash);
  if (!ok) return res.status(401).json({ ok: false, message: "‡∏≠‡∏µ‡πÄ‡∏°‡∏•‡∏´‡∏£‡∏∑‡∏≠‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á" });

  // ‡∏™‡∏£‡πâ‡∏≤‡∏á JWT token
  const token = jwt.sign(
    { id: user.id, email: user.email, role: user.role },
    process.env.JWT_SECRET || "changeme",
    { expiresIn: "7d" }
  );

  res.json({
    ok: true,
    redirectTo: "/thread",
    user: {
      id: user.id,
      email: user.email,
      role: user.role,
      username: user.username,
      avatarUrl: user.avatarUrl || "/static/avatars/default.png",
      bio: user.bio || "",
      socialLink: user.socialLink || "",
      token // <<--- ‡∏™‡πà‡∏á token ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏î‡πâ‡∏ß‡∏¢
    },
  });
});

/* ---------- threads ---------- */
// GET list
app.get("/api/threads", async (req, res) => {
  const categoryId = req.query.category ? parseInt(req.query.category, 10) : null;
  const where = categoryId ? { categoryId } : {};

  const items = await prisma.thread.findMany({
    where,
    include: { author: { select: { id: true, email: true, username: true, avatarUrl: true } } },
    orderBy: { createdAt: "desc" },
  });
  res.json({ ok: true, items });
});

// POST create (‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö multipart + ‡∏£‡∏π‡∏õ optional)
// ‡∏ü‡∏¥‡∏•‡∏î‡πå text: title, body, tags, authorId
app.post("/api/threads", uploadThread.single("cover"), async (req, res) => {
  const { title, body, tags, categoryId } = req.body;
  const auth = req.headers.authorization?.replace(/^Bearer\s+/i, "") || "";
  try {
    const userId = parseInt(req.body.userId, 10);
    const catId = categoryId ? parseInt(categoryId, 10) : null;
    if (!title?.trim() || !body?.trim() || Number.isNaN(userId) || !catId) {
      return res.status(400).json({ ok: false, message: "invalid input" });
    }

    const thread = await prisma.thread.create({
      data: {
        title: title.trim(),
        body: body.trim(),
        tags: tags?.trim() || null,
        authorId: userId,
        coverUrl: req.file ? `/static/thread_images/${req.file.filename}` : null,
        categoryId: catId // <<--- ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ
      },
      include: {
        author: {
          select: { id: true, username: true, email: true, avatarUrl: true }
        }
      }
    });

    res.json({ ok: true, thread });
  } catch (err) {
    console.error(err);
    res.status(500).json({ ok: false, message: "‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏£‡∏∞‡∏ó‡∏π‡πâ‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à" });
  }
});

/* ---------- serve React build (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ) ---------- */
const distPath = path.join(__dirname, "../../client/dist");
if (fs.existsSync(distPath)) {
  app.use(express.static(distPath));
  app.get("/*", (req, res) => {
    if (req.path.startsWith("/api/")) return res.status(404).end();
    res.sendFile(path.join(distPath, "index.html"));
  });
}

// server/src/index.js
app.get("/api/threads/:id", async (req, res) => {
  const id = parseInt(req.params.id, 10);
  if (Number.isNaN(id)) return res.status(400).json({ ok:false, message:"bad id" });

  const t = await prisma.thread.findUnique({
    where: { id },
    include: { author: { select: { id: true, email: true, username: true, avatarUrl: true } } },
  });
  if (!t) return res.status(404).json({ ok:false, message:"not found" });

  res.json({ ok: true, thread: t });
});

app.delete("/api/threads/:id", async (req, res) => {
  const id = parseInt(req.params.id, 10);
  const auth = req.headers.authorization || "";
  const token = auth.replace(/^Bearer\s+/i, "");
  let user = null;
  try {
    user = jwt.verify(token, process.env.JWT_SECRET || "changeme");
  } catch {
    return res.status(401).json({ ok: false, message: "Invalid token" });
  }

  const thread = await prisma.thread.findUnique({ where: { id } });
  if (!thread) return res.status(404).json({ ok: false, message: "not found" });

  // ‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏à‡πâ‡∏≤‡∏Ç‡∏≠‡∏á ‡∏´‡∏£‡∏∑‡∏≠ admin
  if (thread.authorId !== user.id && user.role !== "admin") {
    return res.status(403).json({ ok: false, message: "no permission" });
  }

  // ‡∏•‡∏ö‡∏Ñ‡∏≠‡∏°‡πÄ‡∏°‡∏ô‡∏ï‡πå‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Ç‡∏≠‡∏á‡∏Å‡∏£‡∏∞‡∏ó‡∏π‡πâ‡∏ô‡∏µ‡πâ‡∏Å‡πà‡∏≠‡∏ô
  await prisma.comment.deleteMany({ where: { threadId: id } });

  // ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡πà‡∏≠‡∏¢‡∏•‡∏ö‡∏Å‡∏£‡∏∞‡∏ó‡∏π‡πâ
  await prisma.thread.delete({ where: { id } });
  res.json({ ok: true });
});

// GET comments ‡∏Ç‡∏≠‡∏á‡∏Å‡∏£‡∏∞‡∏ó‡∏π‡πâ‡∏ô‡∏±‡πâ‡∏ô
app.get("/api/threads/:id/comments", async (req, res) => {
  const threadId = parseInt(req.params.id, 10);
  if (Number.isNaN(threadId)) return res.status(400).json({ ok: false, message: "bad id" });

  const thread = await prisma.thread.findUnique({ where: { id: threadId } });
  if (!thread) return res.status(404).json({ ok: false, message: "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Å‡∏£‡∏∞‡∏ó‡∏π‡πâ" });

  const items = await prisma.comment.findMany({
    where: { threadId },
    include: { author: { select: { id: true, username: true, email: true, avatarUrl: true } } },
    orderBy: { createdAt: "asc" },
  });

  res.json({ ok: true, items });
});

// POST comment -> ‡∏Ñ‡∏∑‡∏ô comment ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• author
app.post("/api/threads/:id/comments", async (req, res) => {
  const threadId = parseInt(req.params.id, 10);
  const { body, authorId } = req.body || {};
  if (!body || !authorId) {
    return res.status(400).json({ ok: false, message: "‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö" });
  }
  const thread = await prisma.thread.findUnique({ where: { id: threadId } });
  if (!thread) return res.status(404).json({ ok: false, message: "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Å‡∏£‡∏∞‡∏ó‡∏π‡πâ" });

  const created = await prisma.comment.create({
    data: {
      body: body.trim(),
      threadId,
      authorId: parseInt(authorId, 10),
    },
    include: {
      author: { select: { id: true, username: true, email: true, avatarUrl: true } }
    }
  });

  res.json({ ok: true, comment: created });
});

app.patch("/api/users/:id", uploadAvatar.single("avatar"), async (req, res) => {
  const id = parseInt(req.params.id, 10);
  const { username, bio, socialLink } = req.body;

  try {
    let avatarUrl = undefined;
    if (req.file) {
      avatarUrl = `/static/avatars/${req.file.filename}`;
    }

    const user = await prisma.user.update({
      where: { id },
      data: {
        username: username || undefined,
        avatarUrl: avatarUrl || undefined,
        bio: bio || undefined,
        socialLink: socialLink || undefined
      },
      select: {
        id: true,
        email: true,
        username: true,
        avatarUrl: true,
        role: true,
        bio: true,
        socialLink: true
      }
    });

    res.json({ ok: true, user });
  } catch (err) {
    console.error(err);
    res.status(500).json({ ok: false, message: "‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à" });
  }
});

app.post("/api/users/:id/change-password", async (req, res) => {
  const id = parseInt(req.params.id, 10);
  const { oldPassword, newPassword } = req.body || {};

  if (!oldPassword || !newPassword) {
    return res.status(400).json({ ok: false, message: "‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö" });
  }
  if (newPassword.length < 6) {
    return res.status(400).json({ ok: false, message: "‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 6 ‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£" });
  }

  const user = await prisma.user.findUnique({ where: { id } });
  if (!user) return res.status(404).json({ ok: false, message: "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ" });

  const ok = await bcrypt.compare(oldPassword, user.passHash);
  if (!ok) return res.status(401).json({ ok: false, message: "‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡πÄ‡∏î‡∏¥‡∏°‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á" });

  const passHash = await bcrypt.hash(newPassword, 10);
  await prisma.user.update({ where: { id }, data: { passHash } });

  res.json({ ok: true, message: "‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏£‡∏´‡∏±‡∏™‡∏ú‡πà‡∏≤‡∏ô‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à" });
});

app.get("/api/categories", async (req, res) => {
  const categories = await prisma.category.findMany({ orderBy: { name: "asc" } });
  res.json(categories);
});

app.post("/api/categories", auth, async (req, res) => {
  console.log("BODY", req.body, "USER", req.user);
  if (!req.user || req.user.role !== "admin") {
    return res.status(403).json({ ok: false, message: "forbidden" });
  }
  const { name } = req.body;
  if (!name) return res.status(400).json({ ok: false, message: "‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏∏‡∏ä‡∏∑‡πà‡∏≠‡∏´‡∏°‡∏ß‡∏î‡∏´‡∏°‡∏π‡πà" });
  const cat = await prisma.category.create({ data: { name } });
  res.json({ ok: true, category: cat });
});

function auth(req, res, next) {
  const authHeader = req.headers.authorization;
  if (!authHeader) return res.status(401).json({ ok: false, message: "No token" });
  const token = authHeader.split(" ")[1];
  try {
    req.user = jwt.verify(token, process.env.JWT_SECRET || "changeme");
    next();
  } catch (e) {
    res.status(401).json({ ok: false, message: "Invalid token" });
  }
}

app.delete("/api/categories/:id", auth, async (req, res) => {
  if (!req.user || req.user.role !== "admin") {
    return res.status(403).json({ ok: false, message: "forbidden" });
  }
  const id = parseInt(req.params.id, 10);
  if (Number.isNaN(id)) return res.status(400).json({ ok: false, message: "bad id" });

  try {
    // ‡∏•‡∏ö‡∏´‡∏°‡∏ß‡∏î‡∏´‡∏°‡∏π‡πà ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ thread ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ categoryId ‡∏ô‡∏µ‡πâ ‡∏à‡∏∞ set ‡πÄ‡∏õ‡πá‡∏ô null ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥ (‡∏ñ‡πâ‡∏≤ schema ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á)
    await prisma.category.delete({ where: { id } });
    res.json({ ok: true });
  } catch (err) {
    console.error(err);
    res.status(500).json({ ok: false, message: "‡∏•‡∏ö‡∏´‡∏°‡∏ß‡∏î‡∏´‡∏°‡∏π‡πà‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à" });
  }
});

app.post("/api/reports", async (req, res) => {
  const { threadId, threadTitle, reason } = req.body;
  const auth = req.headers.authorization || "";
  const token = auth.replace(/^Bearer\s+/i, "");
  let user = null;
  try {
    user = jwt.verify(token, process.env.JWT_SECRET || "changeme");
  } catch {
    return res.status(401).json({ ok: false, message: "Invalid token" });
  }
  if (!threadId || !reason) return res.status(400).json({ ok: false, message: "‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö" });
  const report = await Report.create({
    threadId,
    threadTitle,
    reporterId: user.id,
    reporterEmail: user.email,
    reason
  });
  res.json({ ok: true, report });
});

app.get("/api/reports", async (req, res) => {
  const auth = req.headers.authorization || "";
  const token = auth.replace(/^Bearer\s+/i, "");
  let user = null;
  try {
    user = jwt.verify(token, process.env.JWT_SECRET || "changeme");
  } catch {
    return res.status(401).json({ ok: false, message: "Invalid token" });
  }
  if (user.role !== "admin") return res.status(403).json({ ok: false, message: "forbidden" });
  const reports = await Report.find().sort({ createdAt: -1 });
  res.json({ ok: true, reports });
});

app.get("/api/users", async (req, res) => {
  const auth = req.headers.authorization || "";
  const token = auth.replace(/^Bearer\s+/i, "");
  let user = null;
  try {
    user = jwt.verify(token, process.env.JWT_SECRET || "changeme");
  } catch {
    return res.status(401).json({ ok: false, message: "Invalid token" });
  }
  if (user.role !== "admin") return res.status(403).json({ ok: false, message: "forbidden" });

  // ‡∏î‡∏∂‡∏á user ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏à‡∏≤‡∏Å‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• (‡πÄ‡∏ä‡πà‡∏ô Prisma)
  const users = await prisma.user.findMany({
    select: { id: true, email: true, username: true, role: true }
  });
  res.json({ ok: true, users });
});

app.patch("/api/users/:id/role", async (req, res) => {
  const auth = req.headers.authorization || "";
  const token = auth.replace(/^Bearer\s+/i, "");
  let user = null;
  try {
    user = jwt.verify(token, process.env.JWT_SECRET || "changeme");
  } catch {
    return res.status(401).json({ ok: false, message: "Invalid token" });
  }
  if (user.role !== "admin") return res.status(403).json({ ok: false, message: "forbidden" });

  const id = parseInt(req.params.id, 10);
  const { role } = req.body;
  if (!["user", "admin"].includes(role)) {
    return res.status(400).json({ ok: false, message: "role ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á" });
  }

  try {
    await prisma.user.update({
      where: { id },
      data: { role }
    });
    res.json({ ok: true });
  } catch (err) {
    console.error(err);
    res.status(500).json({ ok: false, message: "‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô role ‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à" });
  }
});


app.get("/api/admin/dashboard", async (req, res) => {
  const auth = req.headers.authorization || "";
  const token = auth.replace(/^Bearer\s+/i, "");
  let user = null;
  try {
    user = jwt.verify(token, process.env.JWT_SECRET || "changeme");
  } catch {
    return res.status(401).json({ ok: false, message: "Invalid token" });
  }
  if (user.role !== "admin") return res.status(403).json({ ok: false, message: "forbidden" });

  // ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô user ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
  const userCount = await prisma.user.count();
  // ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Å‡∏£‡∏∞‡∏ó‡∏π‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
  const threadCount = await prisma.thread.count();

  // ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á: ‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏Ñ‡∏ô‡πÄ‡∏Ç‡πâ‡∏≤‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ß‡∏±‡∏ô (mock, ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ï‡∏≤‡∏£‡∏≤‡∏á log ‡∏à‡∏£‡∏¥‡∏á)
  // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏ï‡∏≤‡∏£‡∏≤‡∏á log ‡∏à‡∏£‡∏¥‡∏á ‡πÉ‡∏´‡πâ query ‡∏à‡∏≤‡∏Å log table
  // ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡∏µ‡πâ‡∏ô‡∏±‡∏ö user ‡∏ó‡∏µ‡πà‡∏™‡∏°‡∏±‡∏Ñ‡∏£‡πÉ‡∏´‡∏°‡πà‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ß‡∏±‡∏ô 7 ‡∏ß‡∏±‡∏ô‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
  const dailyUsers = await prisma.user.groupBy({
    by: ['createdAt'],
    _count: { id: true },
    orderBy: { createdAt: 'desc' },
    take: 7,
  });

  res.json({
    ok: true,
    userCount,
    threadCount,
    dailyUsers: dailyUsers.map(d => ({
      date: d.createdAt.toISOString().slice(0, 10),
      count: d._count.id
    }))
  });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`Server running at http://localhost:${PORT}`));
